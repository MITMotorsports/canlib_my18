#include "canlib_{{ computer.name }}.hpp"
#include "bus.hpp"
#include "drivers/inc/{{ system.architecture['name'][computer.architecture].family }}.hpp"

using namespace CANlib;

Raw_Bus_T GetRawBus(Bus_Names_T bus) {
  switch (bus) {
{%- for busnm, rawnm in computer.participation['name']['can'].mapping.items() %}
    case Bus_Names_T::{{ busnm }}:
      return Raw_Bus_T::{{ rawnm }};
{%- endfor %}
    default:
      return Raw_Bus_T::INVALID_BUS;
  }
}

Bus_Names_T GetBusName(Raw_Bus_T bus) {
	switch (bus) {
{%- for busnm, rawnm in computer.participation['name']['can'].mapping.items() %}
    case Raw_Bus_T::{{ rawnm }}:
      return Bus_Names_T::{{ busnm }};
{%- endfor %}
    default:
      return Bus_Names_T::INVALID_NAME;
  }
}

void HandleFrame(Bus_Names_T bus_name, const Frame& frame) {
    if (raw_bus == Bus_Names_T::INVALID_NAME) {
        return;
    }

    uint32_t message_idx = Identify(bus_name, frame);
    if (message_idx > 0) {
        messages[bus_idx][message_idx]->pack(frame);
    }
}

{%- for busnm, rawnm in computer.participation['name']['can'].mapping.items() %}

static void {{busnm}}::update_can() {
  Frame frame;
  ReadFrame(frame, Raw_Bus_T::{{ rawnm }});
  HandleFrame(Bus_Names_T::{{busnm}}, frame);
}
{%- endfor %}

void update_can(void) {
{%- for busnm in computer.participation['name']['can'].subscribe.keys() %}
  {{ busnm }}::update_can();
{%- endfor %}
}
