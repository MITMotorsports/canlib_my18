{%- macro struct_declarations(bus, msg, msg_name=msg.name) -%}
{%- if msg.frame is defined %}
    namespace {{msg_name}} {
        const uint32_t key = 0x{{ '%0X' % msg.key }};
        {% for sub_frame in msg.frame %}
            {{ struct_declarations(bus, sub_frame) }}
        {% endfor %}
    } // {{msg_name}}

{% else %}
    struct {{msg_name}}_T : public Message_T {
        {{msg_name}}_T() = default;
        ~{{msg_name}}_T() = default;
        void unpack(Frame&) override;
        void pack(const Frame&) override;
        uint32_t get_key() override {
            return key;
        }
        {% for atom in msg.atom %}
            {%- if atom.type.isenum() -%}
                enum class {{ atom.name }}_T {                                                                 
                 {%- for enum in atom.type.enum -%}
                     {%- if enum.name == 'NUM_FIELDS' -%}                   
                        {%- raise "Enum name for {{ atom.name }} cannot be NUM_FIELDS" -%}
                       {%- else %}                                                 
                          {{ enum.name }} = {{ enum.value }},
                         {%- endif -%}
                      {%- endfor %}
                     NUM_FIELDS = {{ atom.type.enum | length }}
                 };
            {% endif -%}
        {% endfor %}
        {%- for atom in msg.atom %}
            {%- if atom.type.isenum() %}
                {{ atom.name }}_T {{ atom.name }};
            {%- else %}
                {{ atom.type.ctype() }} {{ atom.name }};
            {%- endif -%}
        {% endfor %}
        const Bus_Names_T name_ = Bus_Names_T::{{ bus.name }};
        {% if msg.period %}
        const Clock::duration period_ = std::chrono::milliseconds({{ get_ms(msg.period) }});
        {% endif %}
        static const uint32_t key = 0x{{ '%0X' % msg.key }};
    };
{% endif %}
{%- endmacro -%}

{%- macro get_keys(msg, msg_names) -%}
{%- if msg.frame is defined -%}
    {{ "::".join(msg_names) }}::key,
    {%- for sub_frame in msg.frame -%}
        {{ get_keys(sub_frame, msg_names + [sub_frame.name]) }}
    {%- endfor -%}
{%- else -%}
     {{"::".join(msg_names)}}_T::key,
{%- endif -%}
{%- endmacro -%}

{%- macro get_message_ranges(msg, msg_names) -%}
{%- if msg.frame is defined -%}
    std::make_pair({{ msg.slice.start }}, {{ msg.slice.length }}),
    {%- for sub_frame in msg.frame -%}
        {{ get_message_ranges(sub_frame, msg_names + [sub_frame.name]) }}
    {%- endfor -%}
{%- else -%}
     std::make_pair(1, 0),
{%- endif -%}
{%- endmacro -%}

{%- macro get_frame_ranges(msg, msg_names, cnt = 0) -%}
{%- if msg.frame is defined -%}
    {{ get_msg_len(msg) }},
    {%- for sub_frame in msg.frame -%}
        {{ get_frame_ranges(sub_frame, msg_names + [sub_frame.name], cnt + 1) }}
    {%- endfor -%}
{%- else -%}
     0,
{%- endif -%}
{%- endmacro -%}

#pragma once

#include <stdint.h>
#include <stdbool.h>
#include <utility>
#include "drivers/driver.hpp"
#include "static.hpp"
#include "clock.h"

namespace CANlib {

struct Message_T {
    Message_T() = default;
    ~Message_T() = default;
    virtual void unpack(Frame&) = 0;
    virtual void pack(const Frame&) = 0;
    virtual uint32_t get_key() = 0;
    void send() {
        if (Clock::now() - last_sent_ > period_)  {
            last_sent_ = Clock::now();
            Frame frame;
            pack(frame);
            TransmitFrame(frame, name_);
        }
    };
    Clock::time_point last_sent_;
    const Bus_Names_T name_ = Bus_Names_T::INVALID_NAME;
    const Clock::duration period_;
};

Message_T** messages[static_cast<uint32_t>(Bus_Names_T::INVALID_NAME)];

{%- for bus in can.bus %}

    namespace {{ bus.name }} {

        {% for msg in bus.frame -%}
            {{ struct_declarations(bus, msg) }}
        {%- endfor %}

        const uint32_t keys[] = {
            {% for msg in bus.frame -%}
                {{ get_keys(msg, [bus.name, msg.name]) }}
            {%- endfor -%}
        };

        const std::pair<uint32_t, uint32_t> frame_id_range[] = {
            std::make_pair(1,0),
            {% for msg in bus.frame -%}
                {{ get_message_ranges(msg, [bus.name, msg.name]) }}
            {%- endfor -%}
        };

        const uint32_t frame_len[] = {
            {% for msg in bus.frame -%}
                {{ get_frame_ranges(msg, [bus.name, msg.name]) }}
            {%- endfor -%}
        };

    } // {{ bus.name }}

{% endfor %}


const uint32_t* keys[] = {
{%- for bus in can.bus -%}
{{bus.name}}::keys,
{%- endfor -%}
};

const std::pair<uint32_t, uint32_t>* frame_id_range[] = {
{%- for bus in can.bus -%}
{{bus.name}}::frame_id_range,
{%- endfor -%}
};

const uint32_t* frame_len[] = {
{%- for bus in can.bus -%}
{{bus.name}}::frame_len,
{%- endfor -%}
};

const size_t can_size[] = {
{%- for bus in can.bus -%}
{{ get_msg_len(bus.frame) }},
{%- endfor -%}
};

void to_bitstring(uint8_t in[], uint64_t *out);

} // CANlib

